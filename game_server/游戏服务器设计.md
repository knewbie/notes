# 游戏服务器设计

## 登录服功能需求
   1. 登录时的密码处理：Secure Remote Password， SRP6

## 服务器公共组件：

###  主循环
会涉及：网络IO，数据库IO，日志IO，逻辑处理等 
伪代码表示：

```
    while (Message* msg = getMessage())
    {
        if (msg 为服务器关闭消息)
            break;
        处理 msg 消息;
    }
```

其中`getMessage()`是从消息队列中取数据：
```
    IMessageQueue {
        void putMessage(Message *);
        Message* getMessage();
    }
```

###  消息队列
消息队列的设计,其中即有读消息,又有写消息,难免会有锁的出现， 锁又会影响性能。
需要有个利弊的权衡。

有关消息队列的实现和线程间消息的传递在 `ACE `中有比较完全的代码实现及描述，
还有一些使用示例，是个很好的参考。
摘抄的解决方案： 

    > 对于如何减少锁竞争次数的优化方案， Ghost Cheng 提出了一种。提供一个队列容器，
    里面有多个队列，每个队列都可固定存放一定数量的消息。网络 IO 线程要给逻辑线程投递
    消息时，会从队列容器中取一个空队列来使用，直到将该队列填满后再放回容器中换另一个
    空队列。而逻辑线程取消息时是从队列容器中取一个有消息的队列来读取，处理完后清空队
    列再放回到容器中。
    这样便使得只有在对队列容器进行操作时才需要加锁，而 IO 线程和逻辑线程在操作自
    己当前使用的队列时都不需要加锁，所以锁竞争的机会大大减少了。
    这里为每个队列设了个最大消息数，看来好像是打算只有当 IO 线程写满队列时才会将
    其放回到容器中换另一个队列。那这样有时也会出现 IO 线程未写满一个队列，而逻辑线程
    又没有数据可处理的情况，特别是当数据量很少时可能会很容易出现。 Ghost Cheng 在他的
    描述中没有讲到如何解决这种问题，但我们可以先来看看另一个方案。
    这个方案与上一个方案基本类似，只是不再提供队列容器，因为在这个方案中只使用了
    两个队列， arthur 在他的一封邮件中描述了这个方案的实现及部分代码。两个队列，一个
    给逻辑线程读，一个给 IO 线程用来写，当逻辑线程读完队列后会将自己的队列与 IO 线程的
    队列相调换。所以，这种方案下加锁的次数会比较多一些， IO 线程每次写队列时都要加锁，
    逻辑线程在调换队列时也需要加锁，但逻辑线程在读队列时是不需要加锁的。
    虽然看起来锁的调用次数是比前一种方案要多很多，但实际上大部分锁调用都是不会引
    起阻塞的，只有在逻辑线程调换队列的那一瞬间可能会使得某个线程阻塞一下。另外对于锁
    调用过程本身来说，其开销是完全可以忽略的，我们所不能忍受的仅仅是因为锁调用而引起
    的阻塞而已。


### 环形缓冲区

按照严格的**先进先出顺序**进行处理，这是环形缓冲区的使用必须遵守的一项要求

环形缓冲区是一项很好的技术，不用频繁的分配内存，而且在大多数情况下，内存的反
复使用也使得我们能用更少的内存块做更多的事

###  发包的方式
两种方案：
- 每个玩家对应一个缓冲区：
每个玩家都会持有对应的socket,可以很方便的发送数据，但是对需要广播的数据，因为是一份相同的，就会有很多份copy,浪费内存。
- 全局缓冲区：
    需要知道每个数据发向哪个socket, 但是在广播数据的发送时，可以只有一份数据就可以，节省内存。

###  状态机

### 事件与信号 
关于事件和信号机制的实现，网络上的开源也比较多，比如 `FastDelegate`， `sigslot`，
`boost::signal` 等，其中 sigslot 还被 Google 采用，在 `libjingle` 的代码中我们可以看到
他是如何被使用的。
